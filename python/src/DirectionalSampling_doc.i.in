%feature("docstring") OT::DirectionalSampling
"Directional sampling algorithm.

Refer to :ref:`directional_simulation`.

Available constructors:
    DirectionalSampling(*event*)

    DirectionalSampling(*event, rootStrategy, samplingStrategy*)

Parameters
----------
event : :class:`~openturns.RandomVector`
    Event we are computing the probability of.
rootStrategy : :class:`~openturns.RootStrategy`
    Strategy used to evaluate the frontiers of
    the event along each direction in the standard space.

    By default,:class:`~openturns.SafeAndSlow`.
samplingStrategy : :class:`~openturns.SamplingStrategy`
    Strategy used to sample directions in the standard space.

    By default, :class:`~openturns.RandomDirection`.

Notes
-----
Let :math:`\inputRV` ba a random vector of dimension :math:`\inputDim`, distributed according to
the measure :math:`\inputMeasure`, and :math:`\model: \Rset^\inputDim \rightarrow \Rset`
be the *limit state function* (where we only wrote the random input parameters). We define the event
:math:`\cD_f` by:

.. math::

    \cD_f = \{\inputRV \in \Rset^{\inputDim} \, | \,\model(\vect{x}) \leq 0\}

The directional sampling algorithm estimates the probability of the event :math:`\cD_f`:

.. math::

    P_f = \Prob{\model\left( \inputRV \right) \leq 0}
        = \int_{\Rset^{\inputDim}} \mathbf{1}_{\{\model(\vect{x}) \leq 0 \}}\inputMeasure(\vect{x})\di{\vect{x}}


The directional sampling algorithm is an accelerated sampling method. As it is performed
in the standard space, it uses an iso-probabilistic transformation, as for :class:`~openturns.FORM`
and :class:`~openturns.SORM` methods. However, it remains based on sampling and
is thus not an approximation method.

In the standard space, the random variates are independent and follow normal distributions with zero
mean and unit variance. Each iteration of the directional sampling algorithm follows the steps:

- According to the specified :class:`~openturns.SamplingStrategy`, one or several directions
  are generated in the standard space. Each direction is computed from a point drawn randomly
  on :math:`\cS = \big\{ \vect{u} \big| ||\vect{u}|| = 1 \big\}` according to the uniform
  distribution on :math:`\cS`.

- Along each generated direction :math:`i`, we find the frontiers of :math:`\cD_f`, i.e. the solutions
  of :math:`g(\vect{x}) = 0` from which we deduce the subset
  :math:`I_i \subset \Rset` that belongs to :math:`\cD_f`.

- For each subset :math:`I_i`, we compute the probability
  :math:`q_i = \Prob{ ||\RVU|| \in I_i }`. As :math:`\RVU` follows a standard normal gaussian vector
  with independent components, :math:`||\RVU||` follows a :math:`\chi` distribution which degree of
  freedom is equal to :math:`\inputDim`.

The probability :math:`P_f` is computed from all the  :math:`q_i` probabilities. If :math:`N` directions have been used, then:

.. math::

    \widehat{P}_{f,DS} = \frac{1}{N} \sum_{i=1}^N q_i

Examples
--------
>>> import openturns as ot
>>> ot.RandomGenerator.SetSeed(0)

Create the output random vector :math:`Y = \model(\inputRV)`:
>>> myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3*E*I)'])
>>> myDistribution = ot.Normal([50.0, 1.0, 10.0, 5.0], [1.0]*4, ot.IdentityMatrix(4))
>>> input_RV = RandomVector(myDistribution)
>>> output_RV = ot.CompositeRandomVector(myFunction, input_RV)

Create the event :math:`\cD_f = \{\inputRV \in \Rset^{\inputDim} \, | \,\model(\vect{x}) \leq -3.0\}`:
>>> threshold = -3.0
>>> myEvent = ot.ThresholdEvent(output_RV, ot.Less(), -3.0)

Create the directional sampling algorithm and the convergence criteria: 
>>> myAlgo = ot.DirectionalSampling(myEvent, ot.MediumSafe(), ot.OrthogonalDirection())
>>> myAlgo.setMaximumOuterSampling(150)
>>> myAlgo.setBlockSize(4)
>>> myAlgo.setMaximumCoefficientOfVariation(0.1)
>>> # Perform the simulation

Run the algorithm and extract the estimated probabilty:
>>> myAlgo.run()
>>> print('Probability estimate=%.6f' % myAlgo.getResult().getProbabilityEstimate())
Probability estimate=0.169716"

// ---------------------------------------------------------------------

%feature("docstring") OT::DirectionalSampling::getRootStrategy
"Get the root strategy.

Returns
-------
strategy : :class:`~openturns.RootStrategy`
    Root strategy used to evaluate the frontiers of
    the event along each direction in the standard space."

// ---------------------------------------------------------------------

%feature("docstring") OT::DirectionalSampling::setRootStrategy
"Set the root strategy.

Parameters
----------
strategy : :class:`~openturns.RootStrategy`
    Root strategy to evaluate the frontiers of
    the event along each direction in the standard space."

// ---------------------------------------------------------------------

%feature("docstring") OT::DirectionalSampling::getSamplingStrategy
"Get the direction sampling strategy.

Returns
-------
strategy : :class:`~openturns.SamplingStrategy`
    Direction sampling strategy used to sample
    directions in the standard space."

// ---------------------------------------------------------------------

%feature("docstring") OT::DirectionalSampling::setSamplingStrategy
"Set the direction sampling strategy.

Parameters
----------
strategy : :class:`~openturns.SamplingStrategy`
    Direction sampling strategy used
    to sample directions in the standard space."
