%feature("docstring") OT::GaussianProcessFitter
"Fit gaussian process models

Refer to :ref:`gaussian_process_regression`.

.. warning::
    This class is experimental and likely to be modified in future releases.
    To use it, import the ``openturns.experimental`` submodule.


Parameters
----------
inputSample, outputSample : :class:`~openturns.Sample` or 2d-array
    The samples :math:`(\vect{x}_k)_{1 \leq k \leq \sampleSize} \in \Rset^\inputDim` and :math:`(\vect{y}_k)_{1 \leq k \leq \sampleSize}\in \Rset^{\outputDim}`.

covarianceModel : :class:`~openturns.CovarianceModel`
    Covariance model of the Gaussian process. See notes for the details.

basis : :class:`~openturns.Basis`
    Functional basis to estimate the trend: :math:`(\varphi_j)_{1 \leq j \leq b}: \Rset^\inputDim \rightarrow \Rset`.
    
    The same basis is used for each marginal output.
    
    Default value is `Basis(0)`, i.e. no trend to estimate

Notes
-----

Refer to :ref:`gaussian_process_regression` to get all the notations and the theoretical aspects. We only detail here the notions related to the class.

We suppose we have a sample :math:`(\vect{x}_k, \vect{y}_k)_{1 \leq k \leq \sampleSize}` where :math:`\vect{y}_k = \model(\vect{x}_k)` for all :math:`k`, with :math:`\model:\Rset^\inputDim \mapsto \Rset^{\outputDim}` a given function.

The class creates the Gaussian process  :math:`\vect{Y}(\omega, \vect{x})` such that the sample :math:`(\vect{y}_k)_{1 \leq k \leq \sampleSize}` is considered as its restriction  on
:math:`(\vect{x}_k)_{1 \leq k \leq \sampleSize}`. It is defined by:

.. math::

    \vect{Y}(\omega, \vect{x}) = \vect{\mu}(\vect{x}) + \vect{W}(\omega, \vect{x})

where:

.. math::

    \vect{\mu}(\vect{x}) = \left(
      \begin{array}{l}
        \mu_1(\vect{x}) \\
        \vdots  \\
        \mu_\outputDim(\vect{x})
       \end{array}
     \right)

with :math:`\mu_\ell(\vect{x}) = \sum_{j=1}^{b} \beta_j^\ell \varphi_j(\vect{x})` and :math:`\varphi_j: \Rset^\inputDim \rightarrow \Rset` the trend functions for :math:`1 \leq j \leq b` and :math:`1 \leq \ell \leq \outputDim`.

Furthermore, :math:`\vect{W}` is a Gaussian process of dimension :math:`\outputDim` with zero mean and
covariance function :math:`\mat{C} = \mat{C}(\vect{\theta}, \vect{\sigma}, \mat{R}, \vect{\lambda})`, where (see
:ref:`covariance_model` for more details on the notations):

- :math:`\vect{\theta}` is the scale vector,
- :math:`\vect{\sigma}` is the standard deviation vector,
- :math:`\mat{R}` is the spatial correlation matrix between the components of :math:`\vect{W}`,
- :math:`\vect{\lambda}` gather some additional parameters specific to each covariance model.



Note that the meta model defined as the trend function: :math:`\metaModel(\vect{x}) = \vect{\mu}(\vect{x})` does not interpolate the input - output sample.

We note:

.. math::

    \vect{\beta}^\ell = \left(
      \begin{array}{l}
        \beta_1^\ell \\
        \vdots  \\
        \beta_{b}^\ell
       \end{array}
     \right) \in \Rset^{b}
     \quad \mbox{ and } \quad
     \vect{\beta} = \left(
      \begin{array}{l}
         \vect{\beta}^1\\
         \vdots  \\
         \vect{\beta}^{\outputDim}
       \end{array}
     \right)\in \Rset^{b\outputDim}

where :math:`n_t = \sum_{\ell = 1}^p n_\ell` is the total number of trend functions for all
output dimensions.

The *GaussianProcessFitter* class estimates the coefficients :math:`\beta_j^\ell` and :math:`\vect{p}` 
where :math:`\vect{p}` is the vector of parameters of the covariance model (a subset of
:math:`\vect{\theta}, \vect{\sigma}, \mat{R}, \vect{\lambda}`) that has been declared as
*active*: by default, the full vectors :math:`\vect{\theta}` and :math:`\vect{\sigma}`. See
:class:`openturns.CovarianceModel` to get details on the activation of the estimation of the other
parameters.

The estimation is done by maximizing the *reduced* log-likelihood of the model (see the equation :eq:`logLikelihoodGP` below).

**Estimation of the parameters:** We want to estimate all the parameters :math:`\left(\beta_j^\ell \right)` for :math:`1 \leq j \leq b`
and :math:`1 \leq \ell \leq \outputDim`, and :math:`\vect{p}`.

We note:

.. math::

    \vect{y} = \left(
      \begin{array}{l}
        \vect{y}_1 \\
        \vdots  \\
        \vect{y}_\sampleSize
       \end{array}
     \right) \in \Rset^{\outputDim \times \sampleSize},
     \quad
     \vect{m}_{\vect{\beta}} = \left(
      \begin{array}{l}
        \vect{\mu}(\vect{x}_1) \\
        \vdots  \\
        \vect{\mu}(\vect{x}_\sampleSize)
       \end{array}
     \right) \in \Rset^{\outputDim \times \sampleSize}

.. math::

    \mat{C}_{\vect{p}} = \left(
      \begin{array}{lcl}
        \mat{C}_{11} & \dots &  \mat{C}_{1 \sampleSize}\\
        \vdots       &       & \vdots \\
        \mat{C}_{\sampleSize1} & \dots &  \mat{C}_{\sampleSize\sampleSize}
       \end{array}
<<<<<<< HEAD
     \right) \in \cS_{\sampleSize \outputDim}^+(\Rset)
=======
     \right) \in \cS_{\outputDim \times \sampleSize}^+(\Rset)
>>>>>>> b740b9a1e (Cosmetics)

where :math:`\mat{C}_{ij} = C_{\vect{p}}(\vect{x}_i, \vect{x}_j)\in \cS_{\outputDim \times \outputDim}^+(\Rset)`.

The likelihood of the Gaussian process on the data set is defined by:

.. math::

<<<<<<< HEAD
    \cL(\vect{\beta}, \vect{p};(\vect{x}_k, \vect{y}_k)_{1 \leq k \leq \sampleSize}) 
    = \dfrac{1}{(2\pi)^{\frac{1}{2} \sampleSize \outputDim} \left|\det\left(\mat{C}_{\vect{p}}\right)\right|^{\frac{1}{2}}}
    \exp\left( -\dfrac{1}{2}\Tr{\left( \vect{y}-\vect{m} \right)} \mat{C}_{\vect{p}}^{-1}  \left( \vect{y}-\vect{m} \right)  \right)

Let :math:`\mat{L}_{\vect{p}}` be the Cholesky factor of :math:`\mat{C}_{\vect{p}}`, i.e. the lower triangular matrix
with positive diagonal such that :math:`\mat{L}_{\vect{p}} \,\Tr{\mat{L}_{\vect{p}}} = \mat{C}_{\vect{p}}`.
Therefore the log-likelihood is:
=======
    \cL(\vect{\beta}, \vect{p};(\vect{x}_k, \vect{y}_k)_{1 \leq k \leq \sampleSize}) = \dfrac{1}{(2\pi)^{\inputDim \times \sampleSize/2} |\det \mat{C}_{\vect{p}}|^{1/2}} \exp\left[ -\dfrac{1}{2}\Tr{\left( \vect{y}-\vect{m}_{\vect{\beta}} \right)} \mat{C}_{\vect{p}}^{-1}  \left( \vect{y}-\vect{m}_{\vect{\beta}} \right)  \right]

Let :math:`\mat{L}_{\vect{p}}` be the Cholesky factor of :math:`\mat{C}_{\vect{p}}`, i.e. the lower triangular matrix with positive diagonal such that :math:`\mat{L}_{\vect{p}} \,\Tr{\mat{L}_{\vect{p}}} = \mat{C}_{\vect{p}}`.
Therefore:
>>>>>>> b740b9a1e (Cosmetics)

.. math::
    :label: logLikelihoodGPAPI

    \log \cL(\vect{\beta}, \vect{p};(\vect{x}_k, \vect{y}_k)_{1 \leq k \leq \sampleSize}) 
    = \alpha - \log \left( \det \left(\mat{L}_{\vect{p}}\right) \right)
    -\dfrac{1}{2}  \left\| \mat{L}_{\vect{p}}^{-1}(\vect{y}-\vect{m}_{\vect{\beta}}) \right\|^2_2

where :math:`\alpha \in \Rset` is a constant independent of :math:`\vect{\beta}` and :math:`\vect{p}`.
The maximization of :eq:`logLikelihoodGP` leads to the following optimality condition for :math:`\vect{\beta}`:

.. math::

    \vect{\beta}^*(\vect{p}^*)
    = \argmin_{\vect{\beta}} \left\| \mat{L}_{\vect{p}^*}^{-1} \left(\vect{y} - \vect{m}_{\vect{\beta}} \right) \right\|^2_2

This expression of :math:`\vect{\beta}^*` as a function of :math:`\vect{p}^*` is taken as a
general relation between :math:`\vect{\beta}` and :math:`\vect{p}` and is substituted into
:eq:`logLikelihoodGP`, leading to a *reduced log-likelihood* function depending solely on :math:`\vect{p}`.

In the particular case where :math:`\outputDim = \dim(\vect{\sigma}) = 1` and :math:`\sigma` is a part of
:math:`\vect{p}`, then a further reduction is possible. In this case, let :math:`\vect{q}` be
the vector :math:`\vect{p}` in which :math:`\sigma` has been substituted by 1.
Therefore:

.. math::

    \left\| \mat{L}_{\vect{p}}^{-1}(\vect{y}-\vect{m}_{\vect{\beta}}) \right\|^2 
    = \frac{1}{\sigma^2} \left\| \mat{L}_{\vect{q}}^{-1} \left(\vect{y} - \vect{m}_{\vect{\beta}} \right) \right\|^2_2.

This shows that :math:`\vect{\beta}^*` is a function of :math:`\vect{q}^*` only, and the optimality
condition for :math:`\sigma` reads:

.. math::

    \vect{\sigma}^*(\vect{q}^*)
    =\dfrac{1}{\sampleSize} 
    \left\| \mat{L}_{\vect{q}^*}^{-1} \left(\vect{y} - \vect{m}_{\vect{\beta}^*(\vect{q}^*)}\right) \right\|^2_2.

This leads to a further reduction of the log-likelihood function where both :math:`\vect{\beta}`
and :math:`\sigma` are replaced by their expression in terms of :math:`\vect{q}`.

The default optimizer is :class:`~openturns.Cobyla` and can be changed thanks to the :meth:`setOptimizationAlgorithm` method.
User could also change the default optimization solver by setting the `GaussianProcessFitter-DefaultOptimizationAlgorithm` resource map key to one of the :class:`~openturns.NLopt` solver names.

It is also possible to proceed as follows:

- ask for the reduced log-likelihood function thanks to the :meth:`getObjectiveFunction` method
- optimize it with respect to the parameters :math:`\vect{\theta}` and  :math:`\vect{\sigma}` using any optimization algorithms (that can take into account some additional constraints if needed)
- set the optimal parameter value into the covariance model used in the *GaussianProcessFitter*
- tell the algorithm not to optimize the parameter using the :meth:`setOptimizeParameters` method

The behaviour of the reduction is controlled by the following keys in :class:`~openturns.ResourceMap`:

<<<<<<< HEAD
- *ResourceMap.SetAsBool('GaussianProcessFitter-UseAnalyticalAmplitudeEstimate', True)* to use the reduction associated to :math:`\sigma`. It has no effect if :math:`d>1` or if :math:`d=1` and :math:`\sigma` is not part of :math:`\vect{p}`
- *ResourceMap.SetAsBool('GaussianProcessFitter-UnbiasedVariance', True)* allows one to use the *unbiased* estimate of :math:`\sigma` where :math:`\dfrac{1}{\sampleSize}` is replaced by :math:`\dfrac{1}{\sampleSize-\outputDim}` in the optimality condition for :math:`\sigma`.
=======
- *ResourceMap.SetAsBool('GaussianProcessFitter-UseAnalyticalAmplitudeEstimate', True)* to use the reduction
  associated to :math:`\sigma`. It has no effect if :math:`d>1` or if :math:`d=1` and :math:`\sigma` is not part of :math:`\vect{p}`
- *ResourceMap.SetAsBool('GaussianProcessFitter-UnbiasedVariance', True)* allows one to use the *unbiased*
  estimate of :math:`\sigma` where :math:`\dfrac{1}{\sampleSize}` is replaced by :math:`\dfrac{1}{\sampleSize-\outputDim}` in the optimality condition for :math:`\sigma`.
>>>>>>> b740b9a1e (Cosmetics)

With huge samples, the `hierarchical matrix <http://en.wikipedia.org/wiki/Hierarchical_matrix>`_  implementation could be used if `hmat-oss` support has been enabled.

This implementation, which is based on a compressed representation of an approximated covariance matrix (and its Cholesky factor), has a better complexity both in terms of memory requirements 
and floating point operations. To use it, the `GaussianProcessFitter-LinearAlgebra` resource map key should be instancied to `HMAT`. Default value of the key is `LAPACK`.

Examples
--------
Create the model :math:`\model: \Rset \mapsto \Rset` and the samples:

>>> import openturns as ot
>>> import openturns.experimental as otexp
>>> g = ot.SymbolicFunction(['x'], ['x + x * sin(x)'])
>>> inputSample = ot.Sample([[1.0], [3.0], [5.0], [6.0], [7.0], [8.0]])
>>> outputSample = g(inputSample)

Create the algorithm:

>>> g1 = ot.SymbolicFunction(['x'], ['sin(x)'])
>>> g2 = ot.SymbolicFunction(['x'], ['x'])
>>> g3 = ot.SymbolicFunction(['x'], ['cos(x)'])
>>> basis = ot.Basis([g1, g2, g3])
>>> covarianceModel = ot.SquaredExponential([1.0])
>>> covarianceModel.setActiveParameter([])
>>> algo = otexp.GaussianProcessFitter(inputSample, outputSample, covarianceModel, basis)
>>> algo.run()

Get the resulting  meta model which is the trend function of the Gaussian process:

>>> result = algo.getResult()
>>> metamodel = result.getMetaModel()"

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getResult
"Get the results of the metamodel computation.

Returns
-------
result : :class:`~openturns.experimental.GaussianProcessFitterResult`
    Structure containing all the results obtained after computation
    and created by the method :py:meth:`run`.
"

//-----------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getInputSample
"Accessor to the input sample.

Returns
-------
inputSample : :class:`~openturns.Sample`
    The input sample :math:`(\vect{x}_k)_{1 \leq k \leq \sampleSize}`."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getOutputSample
"Accessor to the output sample.

Returns
-------
outputSample : :class:`~openturns.Sample`
    The output sample :math:`(\vect{y}_k)_{1 \leq k \leq \sampleSize}` ."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getObjectiveFunction()
"Accessor to the log-likelihood function that writes as argument of the covariance's model parameters.

Returns
-------
logLikelihood : :class:`~openturns.Function`
    The log-likelihood function degined in :eq:`logLikelihoodGP` as a function of :math:`(\vect{\theta}, \vect{\sigma})`.

Notes
-----
The log-likelihood function may be useful for some postprocessing: maximization using external optimizers for example.


Examples
--------
Create the model :math:`\model: \Rset \mapsto \Rset` and the samples:

>>> import openturns as ot
>>> import openturns.experimental as otexp
>>> g = ot.SymbolicFunction(['x0'], ['x0 * sin(x0)'])
>>> inputSample = ot.Sample([[1.0], [3.0], [5.0], [6.0], [7.0], [8.0]])
>>> outputSample = g(inputSample)

Create the algorithm:

>>> basis = ot.ConstantBasisFactory().build()
>>> covarianceModel = ot.SquaredExponential(1)
>>> algo = otexp.GaussianProcessFitter(inputSample, outputSample, covarianceModel, basis)
>>> algo.run()

Get the log-likelihood function:

>>> likelihoodFunction = algo.getObjectiveFunction()
"


// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::run
"Compute the response surface.

Notes
-----
It computes the response surface and creates a
:class:`~openturns.experimental.GaussianProcessFitterResult` structure containing all the results."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getOptimizationAlgorithm
"Accessor to solver used to optimize the covariance model parameters.

Returns
-------
algorithm : :class:`~openturns.OptimizationAlgorithm`
    Solver used to optimize the covariance model parameters.
    Default optimizer is :class:`~openturns.Cobyla`"

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::setOptimizationAlgorithm
"Accessor to the solver used to optimize the covariance model parameters.

Parameters
----------
algorithm : :class:`~openturns.OptimizationAlgorithm`
    Solver used to optimize the covariance model parameters."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::setOptimizeParameters
"Accessor to the covariance model parameters optimization flag.

Parameters
----------
optimizeParameters : bool
    Whether to optimize the covariance model parameters."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getOptimizeParameters
"Accessor to the covariance model parameters optimization flag.

Returns
-------
optimizeParameters : bool
    Whether to optimize the covariance model parameters."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::setOptimizationBounds
"Optimization bounds accessor.

Parameters
----------
bounds : :class:`~openturns.Interval`
    Bounds for covariance model parameter optimization.

Notes
-----
Parameters involved by this method are:

 - Scale parameters,
 - Amplitude parameters if output dimension is greater than one or
   analytical sigma disabled,
 - Additional parameters.

Lower & upper bounds are defined in resource map.
Default lower upper bounds value for all parameters is
:math:`10^{-2}` and defined thanks to the
`GaussianProcessFitter-DefaultOptimizationLowerBound`
resource map key.

For scale parameters, default upper bounds are set as :math:`2`
times the difference between the max and min values of `X` for
each coordinate, `X` being the (transformed) input sample.
The value :math:`2` is defined in resource map
(`GaussianProcessFitter-DefaultOptimizationScaleFactor`).

Finally for other parameters (amplitude,...), default upper bound is set
to :math:`100` (corresponding resource map key is
`GaussianProcessFitter-DefaultOptimizationUpperBound`)
"

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getOptimizationBounds
"Optimization bounds accessor.

Returns
-------
bounds : :class:`~openturns.Interval`
    Bounds for covariance model parameter optimization."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getKeepCholeskyFactor
"Keep Cholesky factor accessor.

Returns
-------
keepCholesky : bool
    Tells whether we keep or not the final Cholesky factor."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::setKeepCholeskyFactor
"Keep Cholesky factor setter.

Parameters
----------
keepCholesky : bool
    Tells whether we keep or not the final Cholesky factor."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::getMethod
" Accessor to the linear algebra method.

Returns
-------
linAlgMethod : int
    The used linear algebra method to fit the model:

    - otexp.GaussianProcessFitterResult.LAPACK or 0: using `LAPACK` to fit the model,

    - otexp.GaussianProcessFitterResult.HMAT or 1: using `HMAT` to fit the model."

// ---------------------------------------------------------------------

%feature("docstring") OT::GaussianProcessFitter::setMethod
" Accessor to the linear algebra method.

Parameters
----------
linAlgMethod : int
    The used linear algebra method to fit the model:

    - otexp.GaussianProcessFitterResult.LAPACK or 0: using `LAPACK` to fit the model,

    - otexp.GaussianProcessFitterResult.HMAT or 1: using `HMAT` to fit the model."
