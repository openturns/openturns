%feature("docstring") OT::RatioOfUniforms
"Ratio of Uniforms simulation algorithm.


.. warning::
    This class is experimental and likely to be modified in future releases.
    To use it, import the ``openturns.experimental`` submodule.

Available constructors:
    RatioOfUniforms(*dist*)

    RatioOfUniforms(*logUnscaledF, rangeF*)
    
Parameters
----------
dist : :class:`~openturns.Distribution`
    Distribution to sample.

logUnscaledPDF : :class:`~openturns.Function`
   Function :math:`\log f` where :math:`f` is proportional to the density function :math:`p` we want to sample.

rangeF : :class:`~openturns.Interval`
    Interval outside which :math:`f=0`.

Notes
-----
This algorithm samples a multivariate distribution whose probability density probability is known up to a multiplicative factor, see [stadlober1990]_ for the unidimensional case and [gobet2016]_ for the multivariate case.

Let :math:`p` be a
probability density function of dimension :math:`\inputDim` and  :math:`f`  a function such that
:math:`p = cf` with :math:`c \in \Rset^+_*`: if :math:`p` is known, then :math:`c=1`; in the other case,
:math:`c` is unknown and difficult to compute.

Let :math:`r \in \Rset^+_*`. Let :math:`A_{f,r}` be the domain defined by:

.. math::

    A_{f,r} & = \left\{ (u, v_1, \dots, v_\inputDim) \in \Rset^{\inputDim+1}\, |\, 0 \leq u \leq f\left(\dfrac{v_1}{u^r},
    \dots, \dfrac{v_\inputDim}{u^r}\right)^{\frac{1}{1+r\inputDim}}\right \}\\
     & = [0, u_{sup}] \times \prod_{i=1}^d [v_{inf, i}, v_{sup, i}]

The Lebesgue measure of :math:`A_{f,r}`  is equal to :math:`\dfrac{1}{c(1+rd)}`.

Let :math:`(U, V_1, \dots, V_\inputDim)` be a random variable uniformly distributed on  :math:`A_{f,r}`.
Then, :math:`\left( \dfrac{V_1}{U^r}, \dots, \dfrac{V_\inputDim}{U^r}\right)` is a random vector
distributed according to :math:`p`.

Under the condition that the functions :math:`\vect{x} \rightarrow f(\vect{x})^{\frac{1}{1+r\inputDim}}` and
:math:`\vect{x} \rightarrow x_if(\vect{x})^{\frac{1}{1+r\inputDim}}` for all :math:`i` are bounded, then the domain
:math:`A_{f,r}` is bounded and can be included in a rectangular bounding box :math:`\tilde{A}_{f,r}`
defined by:

.. math::
    :label: tildeArf_def

    \tilde{A}_{f,r} = \left[0, \sup_{\vect{x}} f(\vect{x})^{\frac{1}{1+r\inputDim}} \right] \times \prod_i
    [ \inf_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+r\inputDim}} ,  \sup_{\vect{x}} x_i f(\vect{x})^{\frac{1}
    {1+r\inputDim}}]


This allows one to sample uniformly the set :math:`A_{f,r}` by rejection sampling inside
:math:`\tilde{A}_{f,r}`.

**How to calculate the rectangular bounding box** :math:`\tilde{A}_{f,r}` **?**

The upper bound :math:`u_{sup}` is calculated by maximizing the log of the function rather than the function:

.. math::

    \sup_{\vect{x}} \log f(\vect{x})

To compute the second part of :math:`\tilde{A}_{f,r}`, we note that:

- If the :math:`v_{sup, i} \leq 0`, then:

  .. math::

      \sup_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+rd}} =\sup_{\vect{x}, x_i \leq 0} x_i
      f(\vect{x})^{\frac{1}{1+r\inputDim}} = 0

  Otherwise, we must solve the maximization problem for :math:`x_i \in \Rset^+`:

  .. math::

      \sup_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+r\inputDim}} =\sup_{\vect{x}, x_i \geq 0} x_i
      f(\vect{x})^{\frac{1}{1+r\inputDim}}

  which is equivalent to the problem:

  .. math::

      \sup_{\vect{x}, x_i \geq 0} \log x_i  + \dfrac{1}{1+r\inputDim} \log f(\vect{x})

- If the :math:`v_{inf, i} \geq 0`, then:

  .. math::

      \inf_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+rd}} = \inf_{\vect{x}, x_i \geq 0} x_i
      f(\vect{x})^{\frac{1}{1+r\inputDim}} = 0

  Otherwise, solve the minimization problem for :math:`x_i \in \Rset^-` and note that:

  .. math::

    \inf_{\vect{x} } x_i f(\vect{x})^{\frac{1}{1+r\inputDim}} = \inf_{\vect{x},  x_i \leq 0 } x_i
    f(\vect{x})^{\frac{1}{1+r\inputDim}} = - \sup_{\vect{x},  x_i \leq 0 } |x_i| f(\vect{x})^{\frac{1
    }{1+r\inputDim}}

  which is equivalent to the problem:

  .. math::

     \sup_{\vect{x}, x_i \leq 0} \log |x_i|  + \dfrac{1}{1+r\inputDim} \log f(\vect{x})


So, in general, we're solving an optimization problem of :math:`\log f(\vect{x})` on
:math:`\Rset^\inputDim` or of :math:`\log |x_i| + \dfrac{1}{1+rd} \log f(\vect{x})` on
:math:`\vect{x}, x_i \geq 0` or on :math:`\vect{x}, x_i \leq 0`.

For the effective solution of these optimization problems, the initial point :math:`\vect{x}_0` must be
such that :math:`f(\vect{x}_0)>0`. Such points are found by scrolling through a Sobol multivariate
low discrepancy sequence: the maximum number of points of the sequence
to generate is fixed by the entry *RatioOfUniforms-CandidateNumber* of :class:`~openturns.ResourceMap`. The maximum number of
points selected as starting points is controlled by the entry *RatioOfUniforms-MaximumMultiStart*.
All the optimization problems are solved using a :class:`~openturns.MultiStart`
algorithm based on these selected starting points. When no point has been selected, an exception is sent.

The acceptance ratio of the rejection algorithm is computed by:

.. math::
   :label: acceptRatio
   
   \tau_{accept} =  \frac{|A_{f,r}|}{|\tilde{A}_{f,r}|}

This class uses the following entries of :class:`~openturns.ResourceMap`:

- *OptimizationAlgorithm*: the optimization algorithm used to compute the bounding box of
  :math:`\tilde{A}_{f,r}`,
- *RatioOfUniforms-CandidateNumber*: maximum number of points of the Sobol low discrepancy sequence of dimension
  :math:`\inputDim` used to find admissible starting points,
- *RatioOfUniforms-MaximumMultiStart*: maximum number of points selected as starting points
  for the multistart optimization algorithm,
- *RatioOfUniforms-NormalizationSampleSize*: size of the sample used to estimate the acceptance ratio.

By default, :math:`r=1`.

Examples
--------
Create a ratio of uniforms when the distribution is known:

>>> import openturns as ot
>>> import openturns.experimental as otexp
>>> from math import pi
>>> f = ot.SymbolicFunction('x', '(1.5+sin(x))*exp(x)')
>>> log_UnscaledPDF = ot.ComposedFunction(ot.SymbolicFunction('x', 'log(x)'), f)
>>> range_PDF = ot.Interval(0.0, 2.0 * pi)
>>> ratioOfU = otexp.RatioOfUniforms(log_UnscaledPDF, range_PDF, False)
>>> collMultiStart = ratioOfU.initialize()
>>> x = ratioOfU.getRealization()
>>> sample = ratioOfU.getSample(10)
>>> ratioOfU = otexp.RatioOfUniforms(ot.Student(8.5, 3))"

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::setLogUnscaledPDFAndRange
"Accessor to the function :math:`\log f` and its range.

Parameters
----------
logUnscaledPDF : :class:`~openturns.Function`
  Function :math:`\log f` where :math:`f \propto p`, the density function we want to sample.

rangeF : :class:`~openturns.Interval`
    Range of the function :math:`f`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::setOptimizationAlgorithm
"Accessor to the optimization algorithm.

Parameters
----------
algo : :class:`~openturns.OptimizationAlgorithm`
    Optimization algorithm that computes the bounds of :math:`\tilde{A}_{f,r}`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::setCandidateNumber
"Accessor to the number of points to generate to find admissible starting points.

Parameters
----------
n : int, :math:`n>0`
    Maximum number of points tested to find admissible points for the optimization algorithm.

Notes
-----
As long as the number of selected starting points is less than the number
defined in :class:`~openturns.ResourceMap`,
entry *RatioOfUniforms-MaximumMultiStart*, a new point of the Sobol low
discrepancy sequence of dimension :math:`\inputDim` is considered. The maximum
points of the Sobol sequence is :math:`n`. If no starting point has been
selected, a warning is sent."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getCandidateNumber
"Accessor to the number of points to generate to find admissible starting points.

Returns
-------
n : int
    Number of points to generate to find admissible points for the optimization algorithm."

Notes
-----
As long as the number of selected starting points is less than the number
defined in :class:`~openturns.ResourceMap`,
entry *RatioOfUniforms-MaximumMultiStart*, a new point of the Sobol low
discrepancy sequence of dimension :math:`\inputDim` is considered. The maximum
points of the Sobol sequence is :math:`n`. If no starting point has been
selected, a warning is sent."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::setMaximumMultiStart
"Accessor to the maximum number of starting points for the multistart algorithm.

Parameters
----------
n : int, :math:`n>0`
    Number of admissible points to keep for the multistart algorithm."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getMaximumMultiStart
"Accessor to the maximum number of starting points for the multistart algorithm.

Returns
-------
n : int
    Number of admissible points to keep for the multistart algorithm."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getLogUnscaledPDF
"Accessor to the function :math:`\log f`.

Returns
-------
logUnscaledPDF : :class:`~openturns.Function`
    The function :math:`\log f` where :math:`f` is proportionnal to the density :math:`p` we want to sample."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getRange
"Accessor to the range of the function :math:`f\propto p`.

Returns
-------
rangeF : :class:`~openturns.Interval`
    Range of the function :math:`f`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getAcceptanceRatio
"Accessor to the acceptance ratio.

Returns
-------
accepRatio : float
    Acceptance ratio :math:`\tau_{accept}` defined in :eq:`acceptRatio`"

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::setR
"Accessor to the :math:`r` parameter.

Parameters
----------
r : float
    The :math:`r` parameter."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getR
"Accessor to the :math:`r` parameter.

Returns
-------
r : float
    The :math:`r` parameter."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::initialize
"Trigger to the optimization problem.

Notes
-----
A call to that method triggers the computation of the bounding box :math:`\tilde{A}_{f,r}`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::isInitialized
"Flag telling if the algorithm has been initialized.

Returns
-------
answer: bool
    Flag telling if the bounding box :math:`\tilde{A}_{f,r}` has already been computed."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getRealization
"Generate a realization.

Returns
-------
point: :class:`~openturns.Point`
    A pseudo-random realization of the distribution."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getOptimizationAlgorithm
"Accessor to the optimization algorithm.

Returns
-------
algo : :class:`~openturns.OptimizationAlgorithm`
    Optimization algorithm that computes the bounds of :math:`\tilde{A}_{f,r}`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getSample
"Generate a sample.

Returns
-------
sample: :class:`~openturns.Sample`
    A pseudo-random sample of the distribution."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getSupU
"Accessor to the :math:`U`-upper bound of :math:`\tilde{A}_{f,r}`.

Returns
-------
supU : float, positive
    The :math:`U`-upper bound of :math:`\tilde{A}_{f,r}` defined in :eq:`tildeArf_def`.

Notes
-----
The :math:`U`-upper bound of :math:`\tilde{A}_{f,r}` is  :math:`\sup_{\vect{x}} f(\vect{x})^{\frac{1}{1+r\inputDim}}`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getInfV
"Accessor to the :math:`V`-lower bound of :math:`\tilde{A}_{f,r}`.

Returns
-------
infV : :class:`~openturns.Point`
    The :math:`V`-lower bound of :math:`\tilde{A}_{f,r}` defined in :eq:`tildeArf_def`.

Notes
-----
The :math:`V`-lower bound of :math:`\tilde{A}_{f,r}` is  :math:`\left( \inf_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+r\inputDim}} \right)_{1 \leq i \leq \inputDim}`."

// ---------------------------------------------------------------------
%feature("docstring") OT::RatioOfUniforms::getSupV
"Accessor to the :math:`V`-upper bound of :math:`\tilde{A}_{f,r}`.

Returns
-------
infV : :class:`~openturns.Point`
    The :math:`V`-upper bound of :math:`\tilde{A}_{f,r}` defined in :eq:`tildeArf_def`.

Notes
-----
The :math:`V`-upper bound of :math:`\tilde{A}_{f,r}` is  :math:`\left( \sup_{\vect{x}} x_i f(\vect{x})^{\frac{1}{1+r\inputDim}} \right)_{1 \leq i \leq \inputDim}`."
